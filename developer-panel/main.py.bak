"""
Panel de Desarrollador para Fiscalberry - Aplicaci√≥n Web Independiente

Esta aplicaci√≥n permite a los desarrolladores monitorear errores de m√∫ltiples
tenants/comercios de Fiscalberry desde un dashboard web centralizado.

Caracter√≠sticas:
- Monitoreo en tiempo real de subcolas de errores por tenant
- Dashboard con filtros por tenant, tipo de error, fecha
- Notificaciones WebSocket en tiempo real
- Autenticaci√≥n JWT para desarrolladores
- API REST para integraci√≥n con otros sistemas
"""

from fastapi import FastAPI, WebSocket, WebSocketDisconnect, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse
from contextlib import asynccontextmanager
import asyncio
import json
import logging
import datetime
from datetime import timedelta
from typing import List, Dict, Optional, Set
import jwt
import pika
import pika.exceptions
from pydantic import BaseModel
import threading
import queue
import os
from pathlib import Path

# Configuraci√≥n
SECRET_KEY = os.getenv("DEVELOPER_PANEL_SECRET", "your-secret-key-change-in-production")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 480  # 8 horas

# Configuraci√≥n de logging m√°s silenciosa para RabbitMQ
logging.getLogger("pika").setLevel(logging.CRITICAL)
logging.getLogger("pika.adapters").setLevel(logging.CRITICAL)
logging.getLogger("pika.adapters.utils").setLevel(logging.CRITICAL)
logging.getLogger("pika.adapters.blocking_connection").setLevel(logging.CRITICAL)
logging.getLogger("pika.adapters.utils.selector_ioloop_adapter").setLevel(logging.CRITICAL)
logging.getLogger("pika.adapters.utils.connection_workflow").setLevel(logging.CRITICAL)

# Configuraci√≥n de logging principal
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Fiscalberry Developer Panel",
    description="Panel de monitoreo de errores para desarrolladores",
    version="1.0.0"
)

# Configuraci√≥n de seguridad
security = HTTPBearer()

# Modelos Pydantic
class LoginRequest(BaseModel):
    username: str
    password: str

class ErrorMessage(BaseModel):
    timestamp: str
    tenant: str
    error_type: str
    message: str
    device_uuid: str
    context: Dict
    exception: Optional[Dict] = None

class DeveloperInfo(BaseModel):
    username: str
    role: str
    permissions: List[str]

# Almac√©n en memoria para errores (en producci√≥n usar Redis o DB)
error_store: Dict[str, List[ErrorMessage]] = {}
connected_websockets: Set[WebSocket] = set()

# Credenciales de desarrolladores (en producci√≥n usar base de datos)
DEVELOPERS = {
    "dev1": {
        "password": "dev123",  # En producci√≥n usar hash
        "role": "senior_developer",
        "permissions": ["view_all_tenants", "export_data", "real_time_monitoring"]
    },
    "dev2": {
        "password": "dev456",
        "role": "developer", 
        "permissions": ["view_assigned_tenants", "real_time_monitoring"]
    }
}

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    """Crea un token JWT para autenticaci√≥n."""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.datetime.now(datetime.UTC) + expires_delta
    else:
        expire = datetime.datetime.now(datetime.UTC) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Verifica el token JWT como dependencia de FastAPI."""
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token inv√°lido",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return username
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token inv√°lido",
            headers={"WWW-Authenticate": "Bearer"},
        )

def verify_token_string(token: str):
    """Verifica el token JWT como string."""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token inv√°lido",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return username
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token inv√°lido",
            headers={"WWW-Authenticate": "Bearer"},
        )

def get_developer_info(username: str = Depends(verify_token)) -> DeveloperInfo:
    """Obtiene informaci√≥n del desarrollador autenticado."""
    if username not in DEVELOPERS:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Desarrollador no encontrado"
        )
    
    dev_data = DEVELOPERS[username]
    return DeveloperInfo(
        username=username,
        role=dev_data["role"],
        permissions=dev_data["permissions"]
    )

class RabbitMQErrorConsumer:
    """Consumer de RabbitMQ para escuchar errores de todos los tenants."""
    
    def __init__(self, rabbitmq_config: Dict[str, str]):
        self.config = rabbitmq_config
        self.connection = None
        self.channel = None
        self.is_running = False
        self.message_queue = queue.Queue()
        
    def connect(self):
        """Conecta a RabbitMQ."""
        try:
            credentials = pika.PlainCredentials(
                self.config["user"], 
                self.config["password"]
            )
            
            parameters = pika.ConnectionParameters(
                host=self.config["host"],
                port=int(self.config["port"]),
                virtual_host=self.config["vhost"],
                credentials=credentials,
                socket_timeout=5,
                connection_attempts=1
            )
            
            self.connection = pika.BlockingConnection(parameters)
            self.channel = self.connection.channel()
            
            # Declarar exchange de errores
            self.channel.exchange_declare(
                exchange="fiscalberry_errors",
                exchange_type='direct',
                durable=True
            )
            
            logger.info("RabbitMQ Error Consumer conectado exitosamente")
            return True
            
        except Exception as e:
            # Ser m√°s silencioso con errores de conexi√≥n
            logger.debug(f"RabbitMQ no disponible: {e}")
            return False
    
    def start_consuming(self):
        """Inicia el consumo de mensajes de error."""
        if not self.connect():
            return
            
        self.is_running = True
        
        def callback(ch, method, properties, body):
            try:
                error_data = json.loads(body.decode('utf-8'))
                error_msg = ErrorMessage(**error_data)
                
                # Almacenar error
                tenant = error_msg.tenant
                if tenant not in error_store:
                    error_store[tenant] = []
                
                error_store[tenant].append(error_msg)
                
                # Mantener solo √∫ltimos 1000 errores por tenant
                if len(error_store[tenant]) > 1000:
                    error_store[tenant] = error_store[tenant][-1000:]
                
                # Notificar a WebSockets conectados
                asyncio.create_task(broadcast_error(error_msg))
                
                logger.info(f"Error recibido de tenant {tenant}: {error_msg.error_type}")
                ch.basic_ack(delivery_tag=method.delivery_tag)
                
            except Exception as e:
                logger.error(f"Error procesando mensaje: {e}")
                ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
        
        # Declarar cola temporal para escuchar todos los errores
        result = self.channel.queue_declare(queue='developer_panel_errors', durable=True)
        queue_name = result.method.queue
        
        # Como el exchange es 'direct', necesitamos hacer bind para cada tenant conocido
        # Por ahora, creamos una cola que capture todos los mensajes del exchange
        # usando una cola especial para el panel de desarrollador
        
        # Declarar la cola espec√≠fica del panel
        self.channel.queue_declare(queue='developer_panel_all_errors', durable=True)
        
        # Para capturar errores de todos los tenants, necesitamos una estrategia diferente
        # Opci√≥n 1: Usar un exchange de tipo 'fanout' adicional
        # Opci√≥n 2: Modificar el error_publisher para enviar tambi√©n a una cola global
        
        # Por ahora, implementamos una soluci√≥n temporal:
        # Escuchamos en una cola espec√≠fica donde se replican todos los errores
        try:
            self.channel.queue_bind(
                exchange="fiscalberry_errors",
                queue="developer_panel_all_errors",
                routing_key="*"  # Esto no funcionar√° con direct, necesitamos una cola especial
            )
        except pika.exceptions.ChannelClosedByBroker:
            # Si falla, declaramos el exchange como topic para usar wildcards
            logger.info("Recreando exchange como topic para wildcard support")
            self.channel = self.connection.channel()
            
            # Declarar exchange como topic que soporta wildcards
            self.channel.exchange_declare(
                exchange="fiscalberry_errors_topic",
                exchange_type='topic',
                durable=True
            )
            
            self.channel.queue_bind(
                exchange="fiscalberry_errors_topic",
                queue="developer_panel_all_errors",
                routing_key="*.errors"  # Captura todos los {tenant}.errors
            )
        
        self.channel.basic_consume(
            queue="developer_panel_all_errors",
            on_message_callback=callback
        )
        
        logger.info("Iniciando consumo de errores...")
        
        try:
            self.channel.start_consuming()
        except Exception as e:
            logger.error(f"Error en consumo: {e}")
        finally:
            self.is_running = False

# Instancia global del consumer
rabbitmq_consumer = None

async def broadcast_error(error_msg: ErrorMessage):
    """Env√≠a el error a todos los WebSockets conectados."""
    if connected_websockets:
        message = {
            "type": "new_error",
            "data": error_msg.dict()
        }
        
        # Crear lista de WebSockets para evitar modificaci√≥n durante iteraci√≥n
        websockets_copy = connected_websockets.copy()
        
        for websocket in websockets_copy:
            try:
                await websocket.send_text(json.dumps(message))
            except Exception as e:
                logger.error(f"Error enviando a WebSocket: {e}")
                connected_websockets.discard(websocket)

def start_rabbitmq_consumer():
    """Inicia el consumer de RabbitMQ en un hilo separado."""
    global rabbitmq_consumer
    
    # Intentar obtener configuraci√≥n desde Fiscalberry
    rabbitmq_config = None
    try:
        # Importar Configberry de Fiscalberry
        import sys
        import os
        fiscalberry_src_path = os.path.join(os.path.dirname(__file__), '..', 'src')
        if fiscalberry_src_path not in sys.path:
            sys.path.insert(0, fiscalberry_src_path)
        
        from fiscalberry.common.Configberry import Configberry
        config = Configberry()
        
        # Intentar configuraci√≥n de RabbitMq primero (m√°s confiable)
        if config.config.has_section("RabbitMq"):
            rabbitmq_config = {
                "host": config.get("RabbitMq", "host", fallback="localhost"),
                "port": config.get("RabbitMq", "port", fallback="5672"),
                "user": config.get("RabbitMq", "user", fallback="guest"),
                "password": config.get("RabbitMq", "password", fallback="guest"),
                "vhost": config.get("RabbitMq", "vhost", fallback="/")
            }
            logger.info("Usando configuraci√≥n RabbitMQ desde RabbitMq (Fiscalberry)")
        
        # Fallback a secci√≥n Paxaprinter
        elif config.config.has_section("Paxaprinter"):
            rabbitmq_config = {
                "host": config.get("Paxaprinter", "rabbitmq_host", fallback="localhost"),
                "port": config.get("Paxaprinter", "rabbitmq_port", fallback="5672"),
                "user": config.get("Paxaprinter", "rabbitmq_user", fallback="guest"),
                "password": config.get("Paxaprinter", "rabbitmq_password", fallback="guest"),
                "vhost": config.get("Paxaprinter", "rabbitmq_vhost", fallback="/")
            }
            logger.info("Usando configuraci√≥n RabbitMQ desde Paxaprinter (Fiscalberry)")
        
    except Exception as e:
        logger.debug(f"No se pudo cargar configuraci√≥n de Fiscalberry: {e}")
    
    # Configuraci√≥n de fallback desde variables de entorno
    if not rabbitmq_config:
        rabbitmq_config = {
            "host": os.getenv("RABBITMQ_HOST", "localhost"),
            "port": os.getenv("RABBITMQ_PORT", "5672"),
            "user": os.getenv("RABBITMQ_USER", "guest"),
            "password": os.getenv("RABBITMQ_PASSWORD", "guest"),
            "vhost": os.getenv("RABBITMQ_VHOST", "/")
        }
        logger.info("Usando configuraci√≥n RabbitMQ desde variables de entorno")
    
    logger.info(f"Configuraci√≥n RabbitMQ: {rabbitmq_config['host']}:{rabbitmq_config['port']}")
    
    rabbitmq_consumer = RabbitMQErrorConsumer(rabbitmq_config)
    
    def run_consumer():
        try:
            rabbitmq_consumer.start_consuming()
        except Exception as e:
            logger.debug(f"RabbitMQ consumer no pudo iniciar: {e}")
    
    consumer_thread = threading.Thread(target=run_consumer, daemon=True)
    consumer_thread.start()
    logger.info("Intento de conexi√≥n RabbitMQ iniciado")

def stop_rabbitmq_consumer():
    """Detiene el consumer de RabbitMQ."""
    global rabbitmq_consumer
    if rabbitmq_consumer:
        rabbitmq_consumer.is_running = False

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Maneja el ciclo de vida de la aplicaci√≥n."""
    # Startup
    logger.info("Iniciando Fiscalberry Developer Panel...")
    start_rabbitmq_consumer()
    yield
    # Shutdown
    logger.info("Cerrando Fiscalberry Developer Panel...")
    stop_rabbitmq_consumer()

app = FastAPI(
    title="Fiscalberry Developer Panel",
    description="Panel de monitoreo de errores para desarrolladores",
    version="1.0.0",
    lifespan=lifespan
)

@app.post("/auth/login")
async def login(login_request: LoginRequest):
    """Endpoint de autenticaci√≥n para desarrolladores."""
    username = login_request.username
    password = login_request.password
    
    if username not in DEVELOPERS or DEVELOPERS[username]["password"] != password:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales inv√°lidas"
        )
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": username}, 
        expires_delta=access_token_expires
    )
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "developer_info": DeveloperInfo(
            username=username,
            role=DEVELOPERS[username]["role"],
            permissions=DEVELOPERS[username]["permissions"]
        )
    }

@app.get("/api/tenants")
async def get_tenants(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Obtiene la lista de tenants activos"""
    verify_token_string(credentials.credentials)
    
    # Usar error_store en lugar de error_storage
    tenants = list(error_store.keys()) if error_store else ["santiago_gay"]
    return {"tenants": tenants}

# TODO: Endpoint futuro para cargar comercios desde base de datos Paxapos
@app.get("/api/comercios/paxapos")
async def get_comercios_paxapos(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """
    Endpoint futuro para cargar todos los comercios desde la base de datos Paxapos.
    Cada comercio tendr√° su propia cola de errores: {tenant_id}_errors
    """
    verify_token_string(credentials.credentials)
    
    # TODO: Implementar conexi√≥n a base de datos Paxapos
    # comercios = await fetch_comercios_from_paxapos_db()
    
    # Estructura de respuesta esperada:
    comercios_ejemplo = [
        {
            "id": 1,
            "nombre": "Santiago Gay Commerce",
            "tenant_id": "santiago_gay",
            "estado": "activo",
            "ultima_conexion": "2025-10-23T14:30:00Z",
            "cola_errores": "santiago_gay_errors",
            "fiscalberry_version": "1.0.0"
        },
        # M√°s comercios...
    ]
    
    return {
        "comercios": comercios_ejemplo,
        "total": len(comercios_ejemplo),
        "implementado": False,  # Cambiar a True cuando se implemente
        "nota": "Este endpoint est√° preparado para implementaci√≥n futura"
    }

@app.get("/api/errors/{tenant}")
async def get_tenant_errors(
    tenant: str, 
    limit: int = 100,
    error_type: Optional[str] = None,
    developer: DeveloperInfo = Depends(get_developer_info)
):
    """Obtiene errores de un tenant espec√≠fico."""
    if tenant not in error_store:
        return {"errors": []}
    
    errors = error_store[tenant]
    
    # Filtrar por tipo de error si se especifica
    if error_type:
        errors = [e for e in errors if e.error_type == error_type]
    
    # Limitar cantidad de resultados
    errors = errors[-limit:]
    
    return {
        "tenant": tenant,
        "errors": [error.dict() for error in errors],
        "total_count": len(error_store.get(tenant, []))
    }

@app.get("/api/stats")
async def get_error_stats(developer: DeveloperInfo = Depends(get_developer_info)):
    """Obtiene estad√≠sticas generales de errores."""
    stats = {}
    
    # Si hay datos en error_store, los procesamos
    for tenant, errors in error_store.items():
        stats[tenant] = {
            "total_errors": len(errors),
            "error_types": {},
            "last_error": None
        }
        
        # Contar tipos de errores
        for error in errors:
            error_type = error.error_type
            if error_type not in stats[tenant]["error_types"]:
                stats[tenant]["error_types"][error_type] = 0
            stats[tenant]["error_types"][error_type] += 1
        
        # √öltimo error
        if errors:
            stats[tenant]["last_error"] = errors[-1].timestamp
    
    # Si no hay datos, mostrar estad√≠sticas por defecto para tenants conocidos
    if not stats:
        tenants_conocidos = ["santiago_gay"]  # Tenant conocido del sistema
        for tenant in tenants_conocidos:
            stats[tenant] = {
                "total_errors": 0,
                "error_types": {},
                "last_error": "Sin errores registrados",
                "status": "Sin actividad reciente"
            }
    
    # Agregar informaci√≥n general del sistema
    total_tenants = len(stats)
    total_errors = sum(tenant_stats["total_errors"] for tenant_stats in stats.values())
    
    return {
        "stats": stats,
        "summary": {
            "total_tenants": total_tenants,
            "total_errors": total_errors,
            "panel_status": "Conectado a RabbitMQ",
            "rabbitmq_host": "www.paxapos.com:5672"
        }
    }

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket para notificaciones en tiempo real."""
    await websocket.accept()
    connected_websockets.add(websocket)
    
    try:
        # Enviar mensaje de bienvenida
        welcome_msg = {
            "type": "connected",
            "message": "Conectado al panel de desarrollador"
        }
        await websocket.send_text(json.dumps(welcome_msg))
        
        # Mantener conexi√≥n viva
        while True:
            try:
                # Esperar por mensajes del cliente (ping/pong)
                await asyncio.wait_for(websocket.receive_text(), timeout=30.0)
            except asyncio.TimeoutError:
                # Enviar ping para mantener conexi√≥n
                ping_msg = {"type": "ping"}
                await websocket.send_text(json.dumps(ping_msg))
                
    except WebSocketDisconnect:
        logger.info("WebSocket desconectado")
    except Exception as e:
        logger.error(f"Error en WebSocket: {e}")
    finally:
        connected_websockets.discard(websocket)

@app.get("/", response_class=HTMLResponse)
async def get_dashboard():
    """P√°gina principal del dashboard."""
    html_content = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Fiscalberry Developer Panel</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            
            body { 
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background: #f8fafc;
                color: #2d3748;
                line-height: 1.6;
            }
            
            .header { 
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 24px 0;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            }
            
            .header-content {
                max-width: 1200px;
                margin: 0 auto;
                padding: 0 24px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .header h1 {
                font-size: 28px;
                font-weight: 600;
                display: flex;
                align-items: center;
                gap: 12px;
            }
            
            .container { 
                max-width: 1200px;
                margin: 0 auto;
                padding: 24px;
            }
            
            .login-container {
                min-height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            }
            
            .login-form { 
                background: white;
                padding: 40px;
                border-radius: 16px;
                box-shadow: 0 20px 60px rgba(0,0,0,0.1);
                max-width: 400px;
                width: 100%;
            }
            
            .login-form h2 {
                text-align: center;
                margin-bottom: 32px;
                color: #2d3748;
                font-size: 24px;
                font-weight: 600;
            }
            
            .dashboard { 
                display: none;
                animation: fadeIn 0.5s ease-in;
            }
            
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(20px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            /* Cards principales */
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 24px;
                margin-bottom: 32px;
            }
            
            .stat-card {
                background: white;
                border-radius: 12px;
                padding: 24px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.05);
                border: 1px solid #e2e8f0;
                transition: transform 0.2s ease, box-shadow 0.2s ease;
            }
            
            .stat-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 8px 24px rgba(0,0,0,0.1);
            }
            
            .stat-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 16px;
            }
            
            .stat-icon {
                width: 48px;
                height: 48px;
                border-radius: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
            }
            
            .stat-icon.system { background: linear-gradient(135deg, #4299e1, #3182ce); }
            .stat-icon.commerce { background: linear-gradient(135deg, #48bb78, #38a169); }
            .stat-icon.errors { background: linear-gradient(135deg, #ed8936, #dd6b20); }
            .stat-icon.alerts { background: linear-gradient(135deg, #e53e3e, #c53030); }
            
            .stat-value {
                font-size: 32px;
                font-weight: 700;
                color: #2d3748;
                margin-bottom: 4px;
            }
            
            .stat-label {
                color: #718096;
                font-size: 14px;
                font-weight: 500;
            }
            
            .stat-trend {
                font-size: 12px;
                padding: 4px 8px;
                border-radius: 6px;
                font-weight: 600;
            }
            
            .trend-up { background: #fed7d7; color: #c53030; }
            .trend-down { background: #c6f6d5; color: #38a169; }
            .trend-stable { background: #bee3f8; color: #3182ce; }
            
            /* Secciones principales */
            .section {
                background: white;
                border-radius: 12px;
                padding: 24px;
                margin-bottom: 24px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.05);
                border: 1px solid #e2e8f0;
            }
            
            .section-header {
                display: flex;
                align-items: center;
                justify-content: between;
                margin-bottom: 24px;
                padding-bottom: 16px;
                border-bottom: 2px solid #f7fafc;
            }
            
            .section-title {
                font-size: 20px;
                font-weight: 600;
                color: #2d3748;
                display: flex;
                align-items: center;
                gap: 12px;
            }
            
            /* Cards de comercios */
            .commerce-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
                gap: 20px;
            }
            
            .commerce-card {
                background: white;
                border: 1px solid #e2e8f0;
                border-radius: 12px;
                padding: 20px;
                transition: all 0.2s ease;
                position: relative;
                overflow: hidden;
            }
            
            .commerce-card::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 4px;
                background: linear-gradient(90deg, #48bb78, #38a169);
            }
            
            .commerce-card.has-errors::before {
                background: linear-gradient(90deg, #ed8936, #dd6b20);
            }
            
            .commerce-card.critical-errors::before {
                background: linear-gradient(90deg, #e53e3e, #c53030);
            }
            
            .commerce-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 16px;
            }
            
            .commerce-name {
                font-size: 18px;
                font-weight: 600;
                color: #2d3748;
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .commerce-status {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 12px;
                font-weight: 600;
                padding: 4px 12px;
                border-radius: 20px;
            }
            
            .status-online { background: #c6f6d5; color: #22543d; }
            .status-warning { background: #ffd6d6; color: #c53030; }
            .status-offline { background: #e2e8f0; color: #718096; }
            
            .commerce-info {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 12px;
                margin-bottom: 16px;
            }
            
            .info-item {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }
            
            .info-label {
                font-size: 12px;
                color: #718096;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .info-value {
                font-size: 14px;
                color: #2d3748;
                font-weight: 600;
            }
            
            .commerce-actions {
                display: flex;
                gap: 8px;
                margin-top: 16px;
            }
            
            /* Botones */
            .btn {
                border: none;
                border-radius: 8px;
                padding: 8px 16px;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                gap: 6px;
                text-decoration: none;
            }
            
            .btn-primary {
                background: linear-gradient(135deg, #4299e1, #3182ce);
                color: white;
            }
            
            .btn-primary:hover {
                background: linear-gradient(135deg, #3182ce, #2c5282);
                transform: translateY(-1px);
            }
            
            .btn-secondary {
                background: #edf2f7;
                color: #4a5568;
            }
            
            .btn-secondary:hover {
                background: #e2e8f0;
            }
            
            .btn-refresh {
                background: linear-gradient(135deg, #48bb78, #38a169);
                color: white;
                min-width: 40px;
                justify-content: center;
            }
            
            .btn-refresh:hover {
                background: linear-gradient(135deg, #38a169, #2f855a);
            }
            
            .btn-refresh:disabled {
                background: #a0aec0;
                cursor: not-allowed;
                transform: none;
            }
            
            /* Secci√≥n de errores */
            .errors-section {
                margin-top: 16px;
                padding-top: 16px;
                border-top: 1px solid #f7fafc;
            }
            
            .error-summary {
                display: flex;
                gap: 12px;
                margin-bottom: 12px;
            }
            
            .error-count {
                background: #fed7d7;
                color: #c53030;
                padding: 4px 8px;
                border-radius: 6px;
                font-size: 12px;
                font-weight: 600;
            }
            
            .error-count.warning {
                background: #feebc8;
                color: #dd6b20;
            }
            
            .error-count.info {
                background: #bee3f8;
                color: #3182ce;
            }
            
            .error-list {
                max-height: 200px;
                overflow-y: auto;
            }
            
            .error-item {
                padding: 12px;
                margin: 8px 0;
                border-radius: 8px;
                border-left: 4px solid;
                font-size: 13px;
                line-height: 1.5;
            }
            
            .error-item.critical {
                background: #fed7d7;
                border-color: #e53e3e;
                color: #742a2a;
            }
            
            .error-item.warning {
                background: #feebc8;
                border-color: #ed8936;
                color: #7b341e;
            }
            
            .error-item.info {
                background: #bee3f8;
                border-color: #4299e1;
                color: #2a4365;
            }
            
            .error-timestamp {
                font-size: 11px;
                color: #718096;
                font-weight: 500;
                display: block;
                margin-bottom: 4px;
            }
            
            .error-message {
                font-weight: 600;
                margin-bottom: 4px;
            }
            
            .error-details {
                font-size: 12px;
                opacity: 0.8;
            }
            
            /* Utilidades */
            input { 
                width: 100%;
                padding: 12px 16px;
                margin: 8px 0;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 14px;
                transition: border-color 0.2s ease;
            }
            
            input:focus {
                outline: none;
                border-color: #4299e1;
                box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
            }
            
            .status-indicator { 
                width: 8px;
                height: 8px;
                border-radius: 50%;
                display: inline-block;
                margin-right: 8px;
            }
            
            .status-indicator.connected { background: #48bb78; }
            .status-indicator.disconnected { background: #e53e3e; }
            .status-indicator.warning { background: #ed8936; }
            
            .connection-status {
                position: fixed;
                top: 24px;
                right: 24px;
                background: white;
                padding: 12px 16px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                border: 1px solid #e2e8f0;
                font-size: 14px;
                font-weight: 600;
                z-index: 1000;
            }
            
            .notification {
                position: fixed;
                top: 80px;
                right: 24px;
                padding: 16px 20px;
                border-radius: 8px;
                color: white;
                font-weight: 600;
                z-index: 1001;
                animation: slideIn 0.3s ease-out;
                box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            }
            
            .notification.success { background: linear-gradient(135deg, #48bb78, #38a169); }
            .notification.error { background: linear-gradient(135deg, #e53e3e, #c53030); }
            .notification.info { background: linear-gradient(135deg, #4299e1, #3182ce); }
            
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            
            .empty-state {
                text-align: center;
                padding: 40px 20px;
                color: #718096;
            }
            
            .empty-state-icon {
                font-size: 48px;
                margin-bottom: 16px;
                opacity: 0.5;
            }
            
            @media (max-width: 768px) {
                .container { padding: 16px; }
                .stats-grid { grid-template-columns: 1fr; }
                .commerce-grid { grid-template-columns: 1fr; }
                .commerce-info { grid-template-columns: 1fr; }
                .header-content { padding: 0 16px; }
                .connection-status { position: relative; top: auto; right: auto; margin-bottom: 16px; }
            }
        </style>
    </head>
    <body>
        <div class="login-container" id="loginForm">
            <div class="login-form">
                <h2>üîß Panel Desarrollador</h2>
                <input type="text" id="username" placeholder="Usuario" value="admin">
                <input type="password" id="password" placeholder="Contrase√±a" value="password">
                <button onclick="login()" class="btn btn-primary">Iniciar Sesi√≥n</button>
                <div id="loginError" style="color: #e53e3e; margin-top: 16px; display: none; text-align: center;"></div>
            </div>
        </div>

        <div class="dashboard" id="dashboard">
            <div class="header">
                <div class="header-content">
                    <h1>üöÄ Fiscalberry Developer Panel</h1>
                    <div id="connectionStatus" class="connection-status">
                        <span class="status-indicator connected" id="statusIndicator"></span>
                        <span id="statusText">Conectado</span>
                    </div>
                </div>
            </div>
            
            <div class="container">
                <!-- Estad√≠sticas principales -->
                <div class="stats-grid" id="statsGrid">
                    <!-- Se cargan din√°micamente -->
                </div>
                
                <!-- Secci√≥n de comercios -->
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">üè™ Comercios Monitoreados</h2>
                    </div>
                    <div class="commerce-grid" id="commerceGrid">
                        <!-- Se cargan din√°micamente -->
                    </div>
                </div>
                
                <!-- Secci√≥n de errores recientes -->
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">üö® Errores Recientes</h2>
                    </div>
                    <div id="recentErrors">
                        <!-- Se cargan din√°micamente -->
                    </div>
                </div>
                
                <!-- Secci√≥n futura para comercios Paxapos -->
                <div id="comercios-section" style="display: none;">
                    <div class="section">
                        <div class="section-header">
                            <h2 class="section-title">üè¢ Comercios Paxapos</h2>
                            <button onclick="loadComerciosFromPaxapos()" class="btn btn-primary">
                                Cargar Comercios
                            </button>
                        </div>
                        <div id="comercios-list"></div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            let token = '';
            let websocket = null;
            
            async function login() {
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                
                try {
                    const response = await fetch('/auth/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username, password })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        token = data.access_token;
                        document.getElementById('loginForm').style.display = 'none';
                        document.getElementById('dashboard').style.display = 'block';
                        connectWebSocket();
                        loadDashboard();
                    } else {
                        document.getElementById('loginError').textContent = 'Credenciales inv√°lidas';
                        document.getElementById('loginError').style.display = 'block';
                    }
                } catch (error) {
                    console.error('Error en login:', error);
                }
            }
            
            function connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                websocket = new WebSocket(`${protocol}//${window.location.host}/ws`);
                
                websocket.onopen = function() {
                    document.getElementById('status').className = 'status connected';
                    document.getElementById('status').textContent = 'Conectado';
                };
                
                websocket.onclose = function() {
                    document.getElementById('status').className = 'status disconnected';
                    document.getElementById('status').textContent = 'Desconectado';
                };
                
                websocket.onmessage = function(event) {
                    const message = JSON.parse(event.data);
                    if (message.type === 'new_error') {
                        addNewErrorToUI(message.data);
                    }
                };
            }
            
            async function loadDashboard() {
                await loadStats();
                await loadTenants();
            }
            
            async function loadStats() {
                try {
                    const response = await fetch('/api/stats', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const data = await response.json();
                    
                    let statsHtml = '';
                    
                    // Mostrar resumen general del sistema
                    if (data.summary) {
                        statsHtml += `
                            <div class="system-summary">
                                <h4>üìä Resumen del Sistema</h4>
                                <div class="summary-grid">
                                    <div class="summary-item">
                                        <span class="summary-number">${data.summary.total_tenants}</span>
                                        <span class="summary-label">Comercios</span>
                                    </div>
                                    <div class="summary-item">
                                        <span class="summary-number">${data.summary.total_errors}</span>
                                        <span class="summary-label">Errores Total</span>
                                    </div>
                                    <div class="summary-item">
                                        <span class="summary-status ${data.summary.panel_status === 'Conectado a RabbitMQ' ? 'connected' : 'disconnected'}">‚óè</span>
                                        <span class="summary-label">${data.summary.panel_status}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    // Mostrar estad√≠sticas por tenant
                    for (const [tenant, stats] of Object.entries(data.stats)) {
                        const hasErrors = stats.total_errors > 0;
                        const statusClass = hasErrors ? 'has-errors' : 'no-errors';
                        
                        statsHtml += `
                            <div class="tenant-card ${statusClass}">
                                <h3>üè™ ${tenant}</h3>
                                <div class="tenant-stats">
                                    <p><strong>Total errores:</strong> ${stats.total_errors}</p>
                                    <p><strong>√öltimo error:</strong> ${stats.last_error || 'N/A'}</p>
                                    ${stats.status ? `<p><strong>Estado:</strong> ${stats.status}</p>` : ''}
                                </div>
                                ${hasErrors ? 
                                    `<div class="error-types">
                                        <strong>Tipos de errores:</strong>
                                        ${Object.entries(stats.error_types || {}).map(([type, count]) => 
                                            `<span class="error-type-badge">${type}: ${count}</span>`
                                        ).join(' ')}
                                    </div>` : ''
                                }
                            </div>
                        `;
                    }
                    
                    if (statsHtml === '') {
                        statsHtml = '<p class="no-data">üìä Cargando estad√≠sticas...</p>';
                    }
                    
                    document.getElementById('stats').innerHTML = statsHtml;
                } catch (error) {
                    console.error('Error loading stats:', error);
                    document.getElementById('stats').innerHTML = '<p class="error-message">‚ùå Error cargando estad√≠sticas</p>';
                }
            }
            
            async function loadTenants() {
                try {
                    const response = await fetch('/api/tenants', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const data = await response.json();
                    
                    let tenantsHtml = '';
                    for (const tenant of data.tenants) {
                        tenantsHtml += `
                            <div class="tenant-card">
                                <h3>${tenant}</h3>
                                <div class="tenant-actions">
                                    <button onclick="loadTenantErrors('${tenant}')" class="btn-primary">Ver Errores</button>
                                    <button onclick="refreshTenantErrors('${tenant}')" class="btn-refresh" title="Refrescar errores">üîÑ</button>
                                </div>
                                <div class="tenant-status">
                                    <span id="status-${tenant}" class="status-indicator">‚óè</span>
                                    <small id="last-error-${tenant}">Sin errores recientes</small>
                                </div>
                            </div>
                        `;
                    }
                    document.getElementById('tenants').innerHTML = tenantsHtml;
                    
                    // TODO: En el futuro, cargar comercios desde base de datos Paxapos
                    // await loadComerciosFromPaxapos();
                    
                } catch (error) {
                    console.error('Error loading tenants:', error);
                }
            }
            
            async function loadTenantErrors(tenant) {
                try {
                    const response = await fetch(`/api/errors/${tenant}?limit=10`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const data = await response.json();
                    
                    let errorsHtml = `
                        <div class="errors-header">
                            <h3>Errores de ${tenant}</h3>
                            <button onclick="refreshTenantErrors('${tenant}')" class="btn-refresh">üîÑ Refrescar</button>
                        </div>
                    `;
                    
                    if (data.errors.length === 0) {
                        errorsHtml += '<p class="no-errors">No hay errores registrados para este comercio.</p>';
                    } else {
                        for (const error of data.errors) {
                            errorsHtml += `
                                <div class="error-item ${getErrorClass(error.error_type)}">
                                    <strong>${error.error_type}</strong> - ${error.timestamp}<br>
                                    ${error.message}
                                </div>
                            `;
                        }
                    }
                    document.getElementById('recent-errors').innerHTML = errorsHtml;
                    
                    // Actualizar indicador de estado del tenant
                    updateTenantStatus(tenant, data.errors.length > 0);
                    
                } catch (error) {
                    console.error('Error loading tenant errors:', error);
                }
            }
            
            async function refreshTenantErrors(tenant) {
                // Mostrar indicador de carga
                const refreshBtn = event.target;
                const originalText = refreshBtn.innerHTML;
                refreshBtn.innerHTML = '‚ü≥ Cargando...';
                refreshBtn.disabled = true;
                
                try {
                    await loadTenantErrors(tenant);
                    
                    // Mostrar notificaci√≥n de √©xito
                    showNotification(`Errores de ${tenant} actualizados`, 'success');
                    
                } catch (error) {
                    console.error('Error refreshing tenant errors:', error);
                    showNotification('Error al actualizar errores', 'error');
                } finally {
                    // Restaurar bot√≥n
                    setTimeout(() => {
                        refreshBtn.innerHTML = originalText;
                        refreshBtn.disabled = false;
                    }, 1000);
                }
            }
            
            function updateTenantStatus(tenant, hasErrors) {
                const statusElement = document.getElementById(`status-${tenant}`);
                const lastErrorElement = document.getElementById(`last-error-${tenant}`);
                
                if (statusElement) {
                    statusElement.className = hasErrors ? 'status-indicator error' : 'status-indicator success';
                    statusElement.textContent = hasErrors ? '‚óè' : '‚óè';
                }
                
                if (lastErrorElement && hasErrors) {
                    lastErrorElement.textContent = 'Errores detectados';
                } else if (lastErrorElement) {
                    lastErrorElement.textContent = 'Sin errores recientes';
                }
            }
            
            function showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }
            
            // TODO: Funci√≥n futura para cargar comercios desde base de datos Paxapos
            async function loadComerciosFromPaxapos() {
                try {
                    // Esta funci√≥n se implementar√° cuando se conecte con la base de datos Paxapos
                    const response = await fetch('/api/comercios/paxapos', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const data = await response.json();
                    
                    let comerciosHtml = '<h2>Comercios Paxapos</h2>';
                    for (const comercio of data.comercios) {
                        comerciosHtml += `
                            <div class="comercio-card">
                                <h3>${comercio.nombre}</h3>
                                <p>ID: ${comercio.id}</p>
                                <p>Estado: ${comercio.estado}</p>
                                <div class="comercio-actions">
                                    <button onclick="loadTenantErrors('${comercio.tenant_id}')" class="btn-primary">Ver Errores</button>
                                    <button onclick="refreshTenantErrors('${comercio.tenant_id}')" class="btn-refresh">üîÑ</button>
                                </div>
                                <div class="error-queue-info">
                                    <small>Cola: ${comercio.tenant_id}_errors</small>
                                </div>
                            </div>
                        `;
                    }
                    document.getElementById('comercios-list').innerHTML = comerciosHtml;
                    
                } catch (error) {
                    console.error('Error loading comercios from Paxapos:', error);
                }
            }
            
            function addNewErrorToUI(errorData) {
                const recentErrors = document.getElementById('recent-errors');
                const errorDiv = document.createElement('div');
                errorDiv.className = `error-item ${getErrorClass(errorData.error_type)}`;
                errorDiv.innerHTML = `
                    <strong>${errorData.error_type}</strong> - ${errorData.timestamp}<br>
                    <strong>Tenant:</strong> ${errorData.tenant}<br>
                    ${errorData.message}
                `;
                recentErrors.insertBefore(errorDiv, recentErrors.firstChild);
                
                // Mantener solo los √∫ltimos 20 errores en UI
                const errors = recentErrors.querySelectorAll('.error-item');
                if (errors.length > 20) {
                    recentErrors.removeChild(errors[errors.length - 1]);
                }
            }
            
            function getErrorClass(errorType) {
                if (errorType.includes('CRITICAL') || errorType.includes('UNKNOWN')) return 'error-critical';
                if (errorType.includes('WARNING')) return 'error-warning';
                return 'error-info';
            }
        </script>
    </body>
    </html>
    """
    return HTMLResponse(content=html_content)

# Funci√≥n duplicada removida - se usa la versi√≥n correcta arriba

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)